<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hello World | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="原文链接：9 Tricks for Kickass JavaScript Developers in 2019原文作者：Lukas Gisder-Dubé 译者：JintNiu 推荐理由：JavaScript 已经成为了当今使用最为广泛、最受欢迎的语言之一，掌握一些使用技巧不仅可以提高开发效率，更有利于思维转换。   过去的一年， JavaScript 在持续变化着，其使用范围也越来越广。接下">
<meta property="og:type" content="article">
<meta property="og:title" content="Hello World">
<meta property="og:url" content="http://jintniu.top/2020/08/03/hello-world/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="原文链接：9 Tricks for Kickass JavaScript Developers in 2019原文作者：Lukas Gisder-Dubé 译者：JintNiu 推荐理由：JavaScript 已经成为了当今使用最为广泛、最受欢迎的语言之一，掌握一些使用技巧不仅可以提高开发效率，更有利于思维转换。   过去的一年， JavaScript 在持续变化着，其使用范围也越来越广。接下">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/1/21/1686da39092644ab?w=2560&h=1858&f=jpeg&s=578203">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/1/21/1686e6bb3db41fd0?w=800&h=534&f=jpeg&s=32973">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/1/22/16874954279b7f74?w=200&h=196&f=png&s=16770">
<meta property="article:published_time" content="2020-08-03T14:59:22.976Z">
<meta property="article:modified_time" content="2020-08-03T15:09:26.127Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/1/21/1686da39092644ab?w=2560&h=1858&f=jpeg&s=578203">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jintniu.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/03/hello-world/" class="article-date">
  <time datetime="2020-08-03T14:59:22.976Z" itemprop="datePublished">2020-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Hello World
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://user-gold-cdn.xitu.io/2019/1/21/1686da39092644ab?w=2560&h=1858&f=jpeg&s=578203" title="Photo by Andrew Worley on Unsplash"></p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://levelup.gitconnected.com/9-tricks-for-kickass-javascript-developers-in-2019-eb01dd3def2a">9 Tricks for Kickass JavaScript Developers in 2019</a><br><br>原文作者：<a target="_blank" rel="noopener" href="https://levelup.gitconnected.com/@gisderdube">Lukas Gisder-Dubé</a> <br><br>译者：<a target="_blank" rel="noopener" href="https://juejin.im/user/5b847cd2e51d4538af60f8cd">JintNiu</a> <br><br>推荐理由：<code>JavaScript</code> 已经成为了当今使用最为广泛、最受欢迎的语言之一，掌握一些使用技巧不仅可以提高开发效率，更有利于思维转换。</p>
</blockquote>
<hr>
<p>过去的一年， <code>JavaScript</code> 在持续变化着，其使用范围也越来越广。接下来，我将针对 <code>JavaScript</code> 的使用，列出 9 条 建议，以帮助你写出更加整洁高效的代码，成为更好的开发者。</p>
<h2 id="1-async-await"><a href="#1-async-await" class="headerlink" title="1. async/await"></a>1. async/await</h2><p><code>JavaScript</code> 极速发展的今天，回调地狱所产生的问题已不复存在。实际开发过程中我们应当尽量避免使用回调函数，除非为了遵守代码库规则或是维护性能。而解决回调地狱的一个常用方法为 <code>Promise</code>，但在代码量较多时使用会适得其反。于是提出了 <code>async / await</code>，使代码结构更加清晰明了，便于阅读和维护。一般而言，可以 <code>await</code> 任何 <code>Promise</code> 以防止正使用的库的返回值为 <code>Promise</code> ，也就是说 <code>async/await</code> 是 <code>Promise</code> 的语法糖，而且使用方法也十分简单：在函数前加 <code>async</code>。下面是一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios.get(<span class="string">&#x27;https://dube.io/service/ping&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> data = result.data</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data&#x27;</span>, data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line">getData()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意:Note that await on the top level is not possible, you can only call an async function.</span><br></pre></td></tr></table></figure>

<p><em><code>async/await</code> 是 ES2017 中引入的，请务必转换代码</em></p>
<h2 id="2-异步控制流"><a href="#2-异步控制流" class="headerlink" title="2. 异步控制流"></a>2. 异步控制流</h2><p>当我们进行异步调用并获得返回值时，通常期望直接获取多个数据集，并且分别操作每个数据集。因此有了以下方式：</p>
<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>假设页面上要展示 Pokemon 数据，可以通过 <code>axios</code> 获取它们的详细信息，我们所期望的是在得到返回值时立即更新页面中的所有数据，而不是等所有调用完成后才进行更新。</p>
<p>我们可以使用 <code>for...of</code> 解决上述问题。 首先循环遍历数组，并在每个循环内执行异步代码，当所有调用都成功时跳出循环。需要注意的是，这种方法虽然会对性能产生一些影响，但也不乏是一个很好的方法。</p>
<p>以下是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myData = [&#123; <span class="attr">id</span>: <span class="number">0</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">dataSet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (entry <span class="keyword">of</span> dataSet) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> axios.get(<span class="string">`https://ironhack-pokeapi.herokuapp.com/pokemon/<span class="subst">$&#123;entry.id&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">const</span> newData = result.data</span><br><span class="line">        updateData(newData)</span><br><span class="line">        <span class="built_in">console</span>.log(myData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateData</span>(<span class="params">newData</span>) </span>&#123;</span><br><span class="line">    myData = myData.map(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (el.id === newData.id) <span class="keyword">return</span> newData</span><br><span class="line">        <span class="keyword">return</span> el</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fetchData(myData)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>译者注：除了循环本身带来的性能问题之外，在使用 <code>async/await</code> 处理异步请求时也会对性能造成影响：如果使用过多 <code>await</code> 语句，而且候这些语句并不需要依赖于之前的语句，则会产生 <code>async/await</code> 地狱，影响性能。</p>
</blockquote>
<blockquote>
<p>可以直接将这些例子复制粘贴到编辑器中运行。</p>
</blockquote>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>如果想要并行获取所有的 Pokemon，我们可以使用 <code>Promise.all</code> 方法来 <code>await</code> 所有 <code>Promise</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> myData = [&#123; <span class="attr">id</span>: <span class="number">0</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;]</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params">dataSet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> pokemonPromises = dataSet.map(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> axios.get(<span class="string">`https://ironhack-pokeapi.herokuapp.com/pokemon/<span class="subst">$&#123;entry.id&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(pokemonPromises)</span><br><span class="line">    results.forEach(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        updateData(result.data)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(myData)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateData</span>(<span class="params">newData</span>) </span>&#123;</span><br><span class="line">    myData = myData.map(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (el.id === newData.id) <span class="keyword">return</span> newData</span><br><span class="line">        <span class="keyword">return</span> el</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fetchData(myData) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em><code>for...of</code> 和 <code>Promise.all</code> 都是 <code>ES6+</code> 引入的，使用时请转换代码。</em></p>
<h2 id="3-解构赋值-amp-默认值"><a href="#3-解构赋值-amp-默认值" class="headerlink" title="3. 解构赋值 &amp; 默认值"></a>3. 解构赋值 &amp; 默认值</h2><p>回到上个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = axios.get(<span class="string">`https://ironhack-pokeapi.herokuapp.com/pokemon/<span class="subst">$&#123;entry.id&#125;</span>`</span>)</span><br><span class="line"><span class="keyword">const</span> data = result.data</span><br></pre></td></tr></table></figure>

<p>现在有一种更简单的方法来实现它：通过解构赋值的方式从对象或数组中获取一个或多个值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> axios.get(...)</span><br></pre></td></tr></table></figure>

<p>重命名变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">data</span>: newData &#125; = <span class="keyword">await</span> axios.get(...)</span><br></pre></td></tr></table></figure>

<p>另一种方法是在解构赋值时指定默认值，这样做可以确保代码不会出现 <code>undefined</code>，也避免手动检查变量的麻烦。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id = <span class="number">5</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(id) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>这些方法也可以用于函数参数，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params">&#123; operands = [<span class="number">1</span>, <span class="number">2</span>], type = <span class="string">&#x27;addition&#x27;</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> operands.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;addition&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> acc + val</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;subtraction&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> acc - val</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;multiplication&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> acc * val</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;division&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> acc / val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [<span class="string">&#x27;addition&#x27;</span>, <span class="string">&#x27;subtraction&#x27;</span>].includes(type) ? <span class="number">0</span> : <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(calculate()) <span class="comment">// 3 </span></span><br><span class="line"><span class="built_in">console</span>.log(calculate(&#123; <span class="attr">type</span>: <span class="string">&#x27;division&#x27;</span> &#125;)) <span class="comment">// 0.5 </span></span><br><span class="line"><span class="built_in">console</span>.log(calculate(&#123; <span class="attr">operands</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="attr">type</span>: <span class="string">&#x27;multiplication&#x27;</span> &#125;)) <span class="comment">// 24 </span></span><br></pre></td></tr></table></figure>

<p><em><code>ES6</code> 引入了解构赋值和默认值，使用时请转换代码。</em></p>
<h2 id="4-真值和虚值"><a href="#4-真值和虚值" class="headerlink" title="4. 真值和虚值"></a>4. 真值和虚值</h2><p>当我们使用默认值时，通常要对现有值进行一系列判断，这种方法使代码变得异常繁琐，而现在我们可以真值（<code>Truthy</code>）和虚值（<code>Falsy</code>）的方式来改进它，不仅可以节省代码量，还使人更加信服。</p>
<p>以下是之前的做法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (myBool === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">if</span> (myString.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isNaN</span>(myNumber)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (myBool) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">if</span> (myString) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="keyword">if</span> (!myNumber) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为 <code>Falsy</code> 和 <code>Truthy</code> 的概念：</p>
<p><strong>Falsy</strong></p>
<ul>
<li>长度为0的字符串</li>
<li>数字 <code>0</code></li>
<li><code>false</code></li>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>NaN</code></li>
</ul>
<p><strong>Truthy</strong></p>
<ul>
<li>空数组</li>
<li>空对象</li>
<li>其他</li>
</ul>
<p>使用真值和虚值时没有确切的比较方式，这类似于我们进行比较时常使用双等号 <code>==</code> 而不是三等号 <code>===</code>。一般而言，这两者的判定方式相同，但在某些情况下也会遇到一些错误，对我来说主要为数字 <code>0</code>。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/21/1686e6bb3db41fd0?w=800&h=534&f=jpeg&s=32973" title="Photo by Philippe Leone on Unsplash"></p>
<h2 id="5-逻辑运算符和三元运算符"><a href="#5-逻辑运算符和三元运算符" class="headerlink" title="5. 逻辑运算符和三元运算符"></a>5. 逻辑运算符和三元运算符</h2><p>逻辑运算符和三元运算符主要用于精简代码，有助于保持代码整洁度，但当他们形成运算链时会显得杂乱。</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符：和（<code>&amp;&amp;</code>）、或（<code>||</code>），一般用于比较两个表达式，返回值为： <code>true</code>、<code>false</code> 或着它的匹配值。如下例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> &amp;&amp; <span class="literal">true</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> &amp;&amp; <span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> &amp;&amp; <span class="literal">false</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> || <span class="literal">true</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> || <span class="literal">false</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> || <span class="literal">true</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> || <span class="literal">false</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们可以将逻辑运算符与真值和虚值的相关知识结合起来。</p>
<p>如果有表达式 <code>A</code> 和 <code>B</code>，针对两种逻辑运算符，有以下规则：</p>
<ul>
<li><code>A &amp;&amp; B</code> ： 当 <code>A</code> 为 <code>false</code> 时则直接返回 <code>A</code> 的值 ；否则返回 <code>B</code> 的值。</li>
<li><code>A || B</code> ： 当 <code>A</code> 为 <code>true</code> 时则直接返回 <code>A</code> 的值 ；否则返回 <code>B</code> 的值。</li>
</ul>
<blockquote>
<p>译者注：上述规则为逻辑运算中的短路现象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> &amp;&amp; &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> &amp;&amp; <span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span> &amp;&amp; <span class="number">5</span>) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log([] || <span class="literal">false</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> || <span class="literal">null</span>) <span class="comment">// null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> || <span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>三元运算符与逻辑运算符非常相似，但有由三个部分组成：</p>
<ol>
<li>条件表达式：其结果为真值或是虚值</li>
<li>返回值 1：条件表达式为真值时，返回返回值 1</li>
<li>返回值 2：条件表达式为虚值时，返回返回值 2</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> lang = <span class="string">&#x27;German&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(lang === <span class="string">&#x27;German&#x27;</span> ? <span class="string">&#x27;Hallo&#x27;</span> : <span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hallo</span></span><br><span class="line"><span class="built_in">console</span>.log(lang ? <span class="string">&#x27;Ja&#x27;</span> : <span class="string">&#x27;Yes&#x27;</span>) <span class="comment">// Ja</span></span><br><span class="line"><span class="built_in">console</span>.log(lang === <span class="string">&#x27;French&#x27;</span> ? <span class="string">&#x27;Bon soir&#x27;</span> : <span class="string">&#x27;Good evening&#x27;</span>) <span class="comment">// Good eveing</span></span><br></pre></td></tr></table></figure>

<h2 id="6-自判断链接"><a href="#6-自判断链接" class="headerlink" title="6. 自判断链接"></a>6. 自判断链接</h2><p>当访问某个嵌套对象的属性时，由于不能确定目标对象或者属性性是否存在，而需要进行一系列判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data</span><br><span class="line"><span class="keyword">if</span> (myObj &amp;&amp; myObj.firstProp &amp;&amp; myObj.firstProp.secondProp &amp;&amp; myObj.firstProp.secondProp.actualData)</span><br><span class="line">    data = myObj.firstProp.secondProp.actualData</span><br></pre></td></tr></table></figure>

<p>显而易见，代码变得非常臃肿难看。而自判断链接（<code>optional chaining</code>）的提出，正好可以满足对嵌套属性的校验需求，并使代码更加清晰整洁。如下例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = myObj?.firstProp?.secondProp?.actualData</span><br></pre></td></tr></table></figure>

<blockquote>
<p>译者注：自判断链接： 检查一个对象上面是否存在某属性。<br><br>出现原因：调用某 <code>Object</code>属性链中的某个属性时，如果该属性不存在，会导致 <code>Cannot read property xxx of undefined</code> 错误。于是自判断链接 <code>?.</code> 出现。<br><br>使用方式：<code>obj?.a?.b?.c</code>。依次对代码中的属性进行判断，如果为 <code>null</code> 或者 <code>undefined</code> 时，结束调用，返回 <code>undefined</code> 。</p>
</blockquote>
<p><em>目前，自判断链接还未纳入官方规范中，只处于第一阶段的实验特性。您需要在 <code>babelrc</code> 中添加 <code>@ babel / plugin-proposal-optional-chaining</code> 后方可使用它。</em></p>
<h2 id="7-类属性-amp-绑定"><a href="#7-类属性-amp-绑定" class="headerlink" title="7. 类属性 &amp; 绑定"></a>7. 类属性 &amp; 绑定</h2><p><code>JavaScript</code> 中经常会用到绑定（<code>bind</code>）。<code>ES6</code> 规范中箭头函数的引入，使 <code>JavaScript</code> 开发人员有了一种将函数自动绑定到执行上下文中的常用方法，同时这种方法非常重要。</p>
<p>由于 <code>JavaScript</code> 中的类方法有特定的调用方式，因此当我们首次声明一个类时不能使用箭头函数，因此需要在其他位置进行函数绑定，比如在构造函数中（以 <code>React.js</code> 为例）。工作当中我总是先定义类方法再对其进行绑定，这种方法非常繁琐且容易出错。但如果使用 <code>class</code> 语法，我们可以通过箭头函数自动绑定它。以下是绑定 <code>_increaseCount</code> 的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="built_in">super</span>(props)</span><br><span class="line">        <span class="built_in">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;&#123;<span class="built_in">this</span>.state.count&#125;&lt;/h1&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="built_in">this</span>._increaseCount&#125;&gt;Increase Count&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    _increaseCount = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123; <span class="attr">count</span>: <span class="built_in">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><em>目前，类属性还未纳入官方规范中，只处于第三阶段的实验特性。您需要在 <code>babelrc</code> 中添加 <code>@ babel / plugin-proposal-class-properties</code> 后方可使用。</em></p>
<h2 id="8-使用-ParcelJS"><a href="#8-使用-ParcelJS" class="headerlink" title="8. 使用 ParcelJS"></a>8. 使用 ParcelJS</h2><p>作为前端开发人员，保证会有打包项目或着转换代码的需求，对此，webpack 已经在很久之前提出先关规范了。第一次使用 webpack v1.0 时，我花了很长时间进行配置，虽然最终运行成功，但整个过程非常痛苦，而且成功后的我变得畏手畏脚，生怕破坏之前的配置。直到几个月前，<code>ParcelJS</code> 的发现使我心情大好，在提供开箱即用功能的同时，它还实现了按需配置，也可以支持类似于 webpack 或 babel 的插件系统，最重要的是它的速度极快。</p>
<blockquote>
<p>译者注：<a target="_blank" rel="noopener" href="https://parceljs.org/">ParcelJS</a>官网显示，parcelJS 的打包速度比 webpack 快 2 倍以上。</p>
</blockquote>
<h2 id="9-封装自己的组件库"><a href="#9-封装自己的组件库" class="headerlink" title="9. 封装自己的组件库"></a>9. 封装自己的组件库</h2><p>这是一个非常有趣的话题，关于它我有很多的想法。对于 <code>CSS</code>，很多人更倾向于使用类似于 BootStrap 这样的组件库。而对于 <code>JavaScript</code>，仍然有人调用 <code>jQuery</code> 或者其他库来实现验证、滑块等功能。首先不否认使用各种库的好处，但还是强烈建议可以亲手实现这些功能，而不是盲目地安装 npm 包。当整个团队正构建一个类似于 <a target="_blank" rel="noopener" href="https://momentjs.com/">moment.js</a> 或 <a target="_blank" rel="noopener" href="https://reactdatepicker.com/">react-datepicker</a> 的大型库（甚至框架）时，你没必要亲手实现它，但可以封装为属于自己的组件库，而且在实现组件库的同时，您可以：</p>
<ol>
<li>准确掌握代码的结构以及运行机制</li>
<li><strong>真正</strong>理解编程及其工作原理</li>
<li>防止代码库变得臃肿</li>
</ol>
<p>直接使用 npm 包是当然非常容易，但如果想要实现某些 npm 包中不具备的功能时则会需要更多的时间：如果软件没有按预期正常工作，或者要将其转换为另一个软件包，您将会花费更多时间来了解其 API 的配置方式。因此，您可以为自己量身定做一套数据自己的组件库。</p>
<hr>
<p><em>关于作者：Lukas Gisder-Dubé 组件并领导了一家初创公司，并任职 CTO 一年半，建立了技术团队。 离开创业公司后，在 <a target="_blank" rel="noopener" href="https://medium.com/@ironhack">Ironhack</a> 担任首席讲师。如今在柏林正建立一家创业咨询公司。查看 <a target="_blank" rel="noopener" href="https://dube.io/">dube.io</a> 以了解更多信息。</em></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16874954279b7f74?w=200&h=196&f=png&s=16770"></p>
<hr>
<h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ol>
<li><a target="_blank" rel="noopener" href="http://www.php.cn/js-tutorial-399247.html">怎样处理 async/await 浪费性能问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.oschina.net/translate/6-reasons-why-javascripts-async-await-blows-promises-away?cmp">Async/Await 优于 Promise 的 6 个理由</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">MDN - Falsy</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">MDN - Truthy</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-optional-chaining">Optional Chaining for JavaScript</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jintniu.top/2020/08/03/hello-world/" data-id="ckden3a490001z8vu6sle13lw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/03/hello-hexo/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          hello hexo
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/03/hello-hexo/">hello hexo</a>
          </li>
        
          <li>
            <a href="/2020/08/03/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>